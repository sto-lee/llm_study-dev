{
  "video_url": "https://www.youtube.com/watch?v=UO-yT7Ugnls",
  "video_id": "UO-yT7Ugnls",
  "title": "What is MySQL?",
  "upload_date": "20220307",
  "channel": "IBM Technology",
  "duration": "9:31",
  "caption": "Hello, my name is Jamil Spain, Developer advocate with the IBM Cloud. And I'm so very excited about my topic for today, which is learning about the MySQL database. This is actually one of the first databases that I actually had my start when I had my training in college as a database architect. And when you think about your application architecture, as a technologist you have to make certain decisions. Well, naturally, you have your front end technologies that you like, the backend services, but that database tier, what I'd like to do today is give you some common criteria that I use to select which databases that I want to use. And the three criteria that I have is the flexibility of use, implementation, and once you have all that fun in development, you really have to start thinking about deployment. Now, one of the great things that I love about MySQL is that you can go up and down the spectrum. Of course, if you're just starting out learning SQL, you have that opportunity to do all the standard things. So standard SQL, and that's really when I first started my first, it was so exciting to see the \"select all from table\". That's really where the magic really dawned on you that, oh man, this can be amazing, what I can do. I have some data in there, I can query and get results. And actually, the first time I actually saw a webpage change with dynamic results, it really blew my mind, I immediately fell in love with this database. So from standard statements, you can get into more complex aggregate functions. Or a lot of the expansive of operators. So, think about operators like between. We're doing dates aggregate can be a lot of your select this as some. You know, all those kind of operations that you can do. And it has even more flexibility for even complex operations, even as you get into things with joins. You can do foreign keys, which can kind of actualize a lot of your normalization. Where I have one table that wants to refer to another one.  For instance, I have a database of books, table of books, and I may want to have authors that are associated with that book. Well, naturally, a book can have more than one author, so that would be a situation where I could have a table of authors and have an actual foreign key that results back to that one book. So, between joins and foreign keys, there's an excellent way to facilitate a lot of those, those those life cycles that you kind of go through when it comes to architecting a database design and even up more complicated to views, store procedures. Views where you can have complex queries that are simplified to a simple \"select all\", simple statement that can be run and stored procedures where you want to have a, basically, a set of statements that run on your particular engine. But really, I wanted to show those kind of levels to show that you can really evolve with it. It's very flexible to meet. Won't be a situation where it's just for one kind of use case that I'll be going for, and then I have to switch over, maybe to another database to kind of work through things. In today's application architecture, we're in the age of the polyglot, meaning I can use more than one technology for my particular application that I want to build. But MySQL is always a strong contender. Very easy to get going and can facilitate a lot of load for my application. All right, so let's cement that down, and let's give this a checkmark. I think we've covered the flexibility, really what I like to cover there. Great to start. Great to build and evolve with. Implementation. So, when he comes here, I like to take a look to see what SDKs are available, all right. With any set of languages, there's normally .. I look in any language, whether it's Java, Python, Node.js, I'll just say JS there, and etc, etc. I really like to see which languages do I have flexibility to work with, and normally I go to my go-tos before. My GoLang ... my favorites are Node.js, GoLang, Java to work in. So naturally there are, it is a common one that is around. With not so much coverage across all language, lets you kind of know that it is maybe new or maybe drivers are still being built to facilitate this, but I can definitely guarantee MySQL is actually one of those that works. I also want to know management tools. So, on the UI perspective, there is a common one. There are a lot of web-based ... ... so, phpMyAdmin, there's a lot of web-based management consoles that I can use if I do want to gain a little velocity outside of using a command line client library on my tool. And also there are some GUI tools. So workbench. If one have a desktop application that I can use, so really a lot of great ecosystem built around supporting not only can I develop, but also the management if I want to load in things or just kind of overall see to my backup restoring from there. So all those elements are really useful to go. And it makes for a great supporting ... ... a great supporting kind of program, a platform. I think of a common scenario that comes out is I have my web server and I have my DB, and this is a great pattern that it can be in the back end to kind of work with. Almost a lot of the common applications that you use today, a lot of the popular blogging platforms are built with this architecture, all right, web server going right with the database, and that's really your stack as it works. All right, so what does that mean? Well, as we do the check mark on implementation. Next, we've built something, we know we've got some exciting code we're working with, we're growing our knowledge of SQL, implementing it. I've got my web based tools to manage it and do my coding in different languages. I have my pattern down pat. The next obvious thing I like to go to is, as I want to move to production, or move to getting this out there, how easy is it to actually deploy? And there are primarily two form factors. You have the, of course, single instance. Which usually for a lot of your starter, starter applications, starter platforms, this is a great way to kind of work with. I can easily start to prototype something out. Have GUI tools to work with it. Start to build, load data in, start playing with what I think I want to build. Whether it's a web front end or mobile, for mobile getting data to the mobile. But I can really get there and really start to expand and really understand what my concept is as it evolves. It can stay single instance, kind of like a monolith, or there is a great way to scale that out, and that pattern for this scale out is really the primary secondary. So primary secondary model. Which means I'll usually have one primary node that I interact with in the same way I do the single instance, and it'll have ways to actually copy that data to any number of secondary instances to really have some redundancy that works. And I've even seen some patterns where I still do my writes to a primary. And maybe I want to read from my secondary. So there's a lot of great separation patterns there to really expand there and maybe use your front end application uses some of the the primary instance as it functions. Maybe you want to build some warehousing tools or to preview your data. They can actually just do a lot of reading if there's no editing from the secondary node there to work with. So this is kind of all I want to cover for this topic. The database is MySQL. Excellent starter tool, highly recommended to get started. Definitely something you want to have as an option in your polyglot. I love to hear in the comments below how you work with this database or if you have some experience with it. Until next time. Technically yours, I'm Jamil Spain. If you have any questions, please drop us a line below, and if you want to see more videos like this in the future, please like and subscribe."
}