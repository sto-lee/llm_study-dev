{
  "video_url": "https://www.youtube.com/watch?v=fHO1X93e4WA",
  "video_id": "fHO1X93e4WA",
  "title": "What is Ansible?",
  "upload_date": "20201124",
  "channel": "IBM Technology",
  "duration": "11:05",
  "caption": "As a developer I quickly got into the habit \nof pushing to GitHub multiple times a day.   So, it surprises me when I hear that Operations \nteams are tackling their infrastructure automation   with a lot of manual processes. Hey everyone, my \nname is Sai Vennam, and today I want to talk about   Ansible. Ansible is an open source infrastructure \nautomation tool, initially developed by Red Hat   and enables you to tackle kind of all of the \nmajor challenges that come with infrastructure.   It enables you to do so with code, or \nin other terms infrastructure as code.   Now Ansible has three major kind of uses and I'll \nstart with the first one because this is generally   the one that people tend to gravitate to when \nthey hear infrastructure automation, and that's   the provisioning use case. So the first step of \nkind of any infrastructure story, you've got to   have some infrastructure in the first place. So, \nlet's say that using Ansible we've already spun   up some environment, let's say it's a VPC and my \nfavorite cloud provider, and within this VPC I've   got three virtual machines. So, we'll say we've \ngot one, two, and then a third one as well. Now   these set of virtual machines are going to \nessentially be our set of hosts. In the Ansible   world, we're going to call this an inventory. So, \nit's basically the set of hosts that Ansible can   work against. So, what we're going to call this \nis an inventory. Now within this inventory we can   actually create even more sub categorizations and \nAnsible calls this patterns. So, let's say these   virtual machines have different, you know, \nunderlying tasks and use cases and services   that they're going to be running. So, these \nfirst two virtual machines will call them web   because they're going to be used for \nweb servers, and then this last one we're going to call this DB because we're going \nto run MySql database on it. So, there we go we've   got our infrastructure we've got that provision \nkind of step already done, and I want to jump to   the second thing that Ansible is really good at \nit's config management. And actually I'd say this   is kind of the main use case that most people \nthink about when they first start to use Ansible,   and this kind of refers to the ability to \nconfigure your actual infrastructure. So a   simple example would be something like operating \nsystem patches, or maybe making sure a certain   service is running, maybe installing some service \nonto a virtual machine. So in our use case today,   let's focus on that, let's focus on how we can \ndo config management with these virtual machines.   Now one of the key tenets of Ansible is that \nit's declarative. Now out there there's kind of   the notion that Ansible can be both declarative as \nwell as procedural or imperative, and the idea is   that, you know with Ansible you declare what you \nwant instead of focusing on how it gets there.   But in essence it can also be considered \nprocedural because the underlying tasks that run   are procedural in nature, but as a user of Ansible \nyou're taking advantage of the declarative aspect   of it meaning you define what you want rather \nthan how to get to whatever it is that you need.   Now today, what we want is to be able to run some \ntasks against those VMs. Let's say we want to run   some OS patches and then install a programming \nlanguage, and then install MySQL. So, what we'll   need is a playbook. So that's what we'll start \nwith first, we'll create an Ansible playbook   and as the name indicates a playbook is going to \nbe a book of tasks or a set of of plays rather.   Now our first play we want to run this against all \nof our hosts and we want to just run a security   patch, we want to make sure they're all running \nthe same version of the same operating system. So,   that will be our first play. So a play is going \nto be kind of consisting of three main things,   you need a name for that play, you need the host \nthat it's going to run against, and you need the   actual tasks that will run. Now in this particular \nplay, let's say that we've got the hosts set to   all because we want to run this against \nall the hosts. And as far as the tasks we'll define some set of tasks like \nsecurity patching and that kind of thing.   Now key thing that I want to mention here, Ansible \ntakes takes advantage of YAML to do its kind of   declarative nature of being able to declare what \nyou want. So this would this is obviously not   a valid YAML but in the real world you know when \nworking with Ansible this would be in YAML format.   So that'll be our first play running \nagainst all of the hosts in our inventory.   Now let's let's create some more plays here. Let's \ncreate a play that runs directly against the hosts   for our web servers. So we call that web, \nright. And this is going to have a set of tasks,   maybe we need to do something like install Go and \ninstall Python, maybe install some other services   that are specific to our web servers. And finally \nwe'll create one more play in this playbook,   and for this one we'll set the host to be our \nDB, and then for instead of tasks let's talk   about something called roles. Ansible has a \nconcept of roles which basically enable you to   group together actions that you run multiple \ntimes. So instead of having to define all of   the tasks every single time you can just define \nthe roles and that will take advantage of you   know the underlying modules and tasks that need \nto be run. By the way, a playbook is one way of   grouping together a set of tasks that you need \nto run, it's a declarative way of doing it,   but if you really want to keep things \nprocedural imperative you can actually run   one-off tasks by themselves and do so in a in an \nimperative way or a procedural way, but this is   kind of the way you would do a fully declarative \napproach to automate a set of tasks against you   know the set of hosts in your inventory. So, this \nis our playbook and we want to execute this now.   That's going to bring me to my second tenet of \nAnsible and that's the fact that it's agent-less. Now Ansible is agent-less in in the sense that \nlike a lot of other infrastructure automation   tools, unlike a lot of other infrastructure \nautomations, you don't actually need to install an   agent on the VMs that were provisioned. So, \nAnsible is able to take advantage of SSH   to actually directly go into those VMs and \nrun the tasks that it needs to. So, let's   see what that looks like right. So we take our \nplaybook and as a user we'll execute Ansible, and   Ansible can execute you know and most unix-like \nenvironments, so we'll execute our playbook and   it'll run against our virtual machines and there \nwe go, we're happy. But here's one thing to think   about. Now chances are we wouldn't be running \nAnsible on our local machine, right. At the   end of the day it has to store SSH keys and a \nlot of kind of other secure configuration and   you're not really trying to run automation off \nyour local machine. So there's a capability out   there called AWX, or Ansible tower, which is \nthe downstream project of the open source AWX,   and that's basically a graphical interface and \nset of APIs that enable you to run Ansible and   operationalize it across your organization. So \nwhether you're using Ansible, or Ansible Tower, a   user will come in execute that playbook and there \nwe go, we'll have our config management executed.   Now the third aspect that I want to talk about \nwith Ansible is the fact that it's idempotent.   Now what exactly does that mean? So idempotent refers to an operation that can be   run multiple times without changing beyond the \ninitial application. In other terms, the first   time I run this operation it should recognize \nthat the security patches need to be installed,   the services need to be installed, the Python and \nGo and MySQL, or whatever needs to be installed   has to be done. The second time I execute that \nsame playbook it's going to recognize it's already   done it and it's going to say hey nothing needs \nto be done. But let's say I come back my second   day and I say oh we need to actually update the \noperating system version from you know 1.0 to 1.1,   and we run this same playbook \nand Ansible, or Ansible Tower,   and then recognize it and says hey that operating \nsystem has changed but nothing else did it's going   to execute the only action needs to to kind of \nresolve that difference. Now one thing to consider   all of these tasks have underlying modules that \npower them and you want to make sure make sure   that the modules themselves are programmed in \na way that's idempotent. And this is important   and it kind of brings me to my last point \nhere is that Ansible is community driven.   That means that if I'm trying to do these things \nin a playbook that I kind of outline today   chances are someone out there has already \ndeveloped the playbooks, the modules, the tasks,   that I need to actually do those operations. Those \nare basically published as collections in what's   called Ansible Galaxy, which is a repository where \ndevelopers can kind of contribute their Ansible   kind of modules, or playbooks, or tasks whatever \nthey might have created in the ecosystem. That's   one of the great things about Ansible is that it's \nso community driven that chances are whatever I'll   need to do I'll be able to find in that galaxy, \nAnsible Galaxy. The one kind of disclaimer I'll   say, make sure run these operations locally, \nmake sure they're item potent, make sure   that you know executing them multiple times \nresponds in a way that's kind of predictable.   So all that being said, we've kind of talked \nabout how Ansible is a declarative language,   it doesn't require an agent to be able to \nexecute in these kind of end environments   in these virtual machines. It's idempotent based \non the modules that you're using to enable you to   avoid things like config drift by making sure \nthat any changes that you make should be done   in your infrastructure automation story, \nwhether it's playbooks, or roles, or modules.   And then finally, you know you can rest easy \nknowing that chances are whatever you need to   automate is available in the community. Now \nthe third use case I mentioned, there are   three things that you can do with Ansible, it's \ngoing to be app deployment. Now I'm not going to   go into too much detail here today about the app \ndeployment use case, but the fact is you can use   Ansible to then take it a step further and deploy \nyour actual web applications and workloads into   the virtual machines, it's also a capability \navailable by Ansible. I hope this was helpful.   If you like this video or have any comments, \nbe sure to drop a like or comment below.   Stay tuned and follow us for more videos \nlike this in the future. Thank you."
}