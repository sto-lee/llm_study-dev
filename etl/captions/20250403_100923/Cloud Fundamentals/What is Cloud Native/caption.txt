Hi, I'm Andrea Crawford and I'm with IBM Cloud. So, today we're going to talk about cloud native applications. In the heritage world we have our lumpy, monolithic applications, and in the new world we have our microservices living on the cloud. If we take a look at this diagram here, we see we have cloud infrastructure. This is your private, your public, and your enterprise infrastructure. Cloud-native applications apply to hybrid and multicloud situations. We also have our scheduling and orchestration layer. This layer is all about control planes like our Kubernetes. We also have our application and data services layer. This layer is all about backing services and being able to integrate our application code with existing services that may be available on other clouds, or even on-premises. We have our application run times, these are what were traditionally, or conventionally, known as middleware. And over here, well, that's where we have our cloud native applications. This is the sweet spot right up here. So, our application code is actually designed, built and delivered very differently for cloud-native than it would be for conventional, monolithic, lumpy applications over here. So, let's talk a little bit about why cloud native applications can actually leverage benefits like enabling innovation, business agility, - and, most importantly from a technology perspective, the commoditization of the solution stack over here. So, as time has progressed and technologies have matured and emerged, a lot of the services are actually being re-factored lower down in this stack. This means that core services are starting to have a lower center of gravity, freeing up innovation at this level over here. So, what are our use-cases for when to build a cloud-native app? Star everything. Everything that lives in the cloud should have a cloud-native app design and approach. This means our application code needs to be instrumented with things like standardized logging, standardize events, and being able to match those logging and events to a standard catalog that multiple microservices and cloud-native apps can use. The last thing we want to do is have our development squads have to figure out what their log and event messages should be. Let's standardize that because we want to be able to commoditize that as well. We also need to have things like distributed tracing. When we get over into the microservices world over here, we have a lot of moving parts. This means we're going to need to leverage services core to the system like load balancing, service discovery, and routing. These are the kinds of things that are commoditized in this layer here with things like Istio, and with the emergence of newer projects like Knative. If you read the tea leaves, I think we're going to find these types of technologies embedded into this control plane layer here. But they're still more innovation to come. There are other technologies like Tekton, which actually address CI pipelines specifically for cloud-native applications that leverage Docker and Kubernetes. And so, if we were to recognize the benefits for cloud-native apps and to sum it all up: we are all about enterprise and engineering at scale. Thank you for watching this video. If you would like to see more videos like this, you can subscribe to the IBM Cloud YouTube channel. If you have any questions or comments drop a line below.