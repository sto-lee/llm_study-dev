{
  "video_url": "https://www.youtube.com/watch?v=o2HJCGcYwoU",
  "video_id": "o2HJCGcYwoU",
  "title": "What is Event Driven Architecture (EDA)?",
  "upload_date": "20210521",
  "channel": "IBM Technology",
  "duration": "12:10",
  "caption": "What are event-driven architectures? And how can \nthey enable real-time user interactions, pluggable   microservices, and extensible streaming and data \nanalytics? My name is Whitney, I'm on the Cloud   team here at IBM. Before I dig in on event driven \narchitecture, specifically I'd like to talk about   system design, more generally and specifically \nthe reactive manifesto. The reactive manifesto   is a set of community-driven guidelines that are \nintended to give a cohesive approach to systems   design. So, at the core of the reactant manifesto \nwe have, we want our system to be message driven. And so, specifically asynchronous messaging. And then also, we want our our \nsystem design to be scalable, and we want it to be resilient. So this implies distributed systems or Kubernetes. \nSo by scalable we mean that we want the   hardware used to expand as the workload \nexpands and contract as the workload contracts   and by resilient we mean we we don't \nwant any single point of failure   and if the system does fail we want it to be able \nto tolerate tolerate that elegantly so with this   foundation in place we should be able to build a \nsystem that is responsive responsive is the value on top of that we can expect \na system that is maintainable so it means it's easy to change easy to fix a bug \nor do an update and we want one that is extensible so we should be able to expand the system easily   so now that we have the core of what we \nwant our systems designed to look like   now let's talk about let's level set \nhere and talk about like what is an event   so an event is a statement of fact an immutable \nstatement of fact about something that happened   in the past so let's give that some context \nwe'll talk about a retail application   so a retail application has a checkout service   and that checkout service is going to want \nto communicate with an inventory service a shipping service and a contact service so with the messaging model if the inventory wants \nto know what the checkout is doing the checkout   will send a message directly to inventory \nto let the inventory know a checkout happen   and another one directly to shipping and directly \nto contact so with messaging we have targeted delivery um not only that but inventory \ncan maybe send a message back to   checkout it can be a conversational \ndelivery conversational messaging   and then finally let's talk about where that \nmessage lives before it's sent it's it's   lives on the host service or on the producing \nservice when it's received it lives on the um   it lives on the host service until it's received \nby the consuming service or in the case of a   message broker it might sit on a machine in \nbetween but regardless the the data persistence is transient now let's compare that to eventing so if \nour checkout service is producing events   it's producing an event every time a checkout \nhappens without any concern to which service   is consuming that and so with that we have a \nsystem that's highly scalable so we have um   three services here interested in the checkout \nbut even if we expand it to a hundred services   listening to check out that wouldn't affect \nwhat the checkout service is doing in any way   not only that when we have all the checkouts \nin a row we come up with an event log   and it can be replayable \nso we have a stream history   and a history of everything that that \nevery checkout event that has happened and then our data persistence depending on how the \ncluster is set up it can be set up to be immutable   it can be there forever as long as you have the \nphysical hardware to back it up so we have um   instead of having transient data persistent \nso we have uh permanent or possibly permanent not immutable but permanent data persistence e and \nt um so this is the foundation of our event driven   architecture so we have a resilient a reactive \nresponsive system design and then that message   driven element is is event messaging specifically \nso when we go into our proper event design the   first thing we're going to consider are our event \nproducers so we might have a web application   that produces events and we \nmight have a a mobile application and let's say we also have an edge device that's \nproducing events so uh internet of things device and all of these are producing \nevents into our system so so this piece of the system here that \nhas all the events running through it   this is called the event backbone so what does this system enable   well first of all we have our event logs being \nproduced by all the producing applications so the event logs can do a few things first it \ncan trigger an action so if we have an internet   of things device let's say our internet of things \ndevice is a robot vacuum cleaner and when we turn   on that robot vacuum cleaner it spins up a pod \non the infrastructure and that pod is a function   as a service so function as a service is a modular \npiece of code often associated with an edge device   that doesn't exist on a server on the server until \nit is turned on and that's when it is spun up so   that's called serverless function as a service \nis sits on top of serverless infrastructure   but the point is that event triggers an action \nof the with the robot vacuum cleaner to spin up   bounce all around the house make everything \nsqueaky clean and then when the function is   finished running it powers down and perhaps \nthat'll cause our function as a service to send   another event back into the system to let \nit know that the the function is complete   another cool thing about the event log is it \ncan be used to help optimize and customize data   persistence so if our web application is our maybe \nit's our retail application that we talked about   before and it's doing a stream of checkout events \nwell our inventory service can be reading from   that and it's keeping track of a local data \nstore that's keeping track of the inventory   so our inventory service will consume from \nthat data stream from the web application it'll   modify the local data and then it'll produce \nagain into the event backbone and so this new   stream is giving the most current inventory \nto any other application in the system that   wants to consume from it and so while we're \ntalking about data another thing that happens   we can save all of the data that comes through the \nsystem so all the raw data or all of the transform   data here at the end once it goes through the \nsystem we'll save it all in a huge data lake and this is what's going to power \nreally data-heavy applications   like ai for example and the data lake is \naccessible from anywhere in the system   that any service that you let consume from it so another thing that our event-driven \narchitectures can enable are a stream processing   so this is built on top of \nthe apache kafka streams api   so let's say that our mobile app is producing \nlet's say it's a music streaming service and   every time let's say up until your in your whole \nlife up until this point you've been listening to   only miley cyrus and britney spears but today you \ndecide you know what i want to see what jay-z is   about and you turn jay-z on well immediately \nyour streaming app is showing you kanye west   and lauren hill and giving you ideas about what \nyou might want to listen to next so that stream   processing is a really powerful and what gives \nthe gives real-time calculations like if it's a   ride share app you um that you know exactly how \nfar away your ride is but it can also be used to   implement business rules and business policies \nand it can be used for real-time analytics and then let's also talk about with \nour system the communications layer so specifically it's called pub sub communication   for publish subscribe so we could have any \nmicroservice a containerized microservice and just like we talked about before with it being \nextensible we can very easily plug it into we can   write a new microservice and plug it into our \nsystem and immediately have it start consuming   from any stream and producing to a new stream or \neven producing to a stream that already exists   and none of the other applications need \nto be concerned with it at all so it's   highly plugable not only that but because \nof the stream history we talked about before   when you plug it into the system you don't have \nto have it start consuming from right this moment   it can be consuming from as long as from the \nbeginning of your application if you've been   saving your stream history for that long so \nas long as that stream history persists when   you plug in a new system it can consume from \neither the old data or can be consumed from   the present moment so with that we talked about \nthe major benefits of event driven architecture   that sit on top of the reactive manifesto ideas \nfor system design with eventing at its core"
}