{
  "video_url": "https://www.youtube.com/watch?v=CAQ_a2-9UOI",
  "video_id": "CAQ_a2-9UOI",
  "title": "Observability vs. APM vs. Monitoring",
  "upload_date": "20210205",
  "channel": "IBM Technology",
  "duration": "9:40",
  "caption": "These days I hear the terms \nObservability, Monitoring, and APM,   or Application Performance Management \nthrown around seemingly interchangeably,   but these terms actually mean quite different \nthings. So let's dive in head first and see an   example of how exactly these things differ. So to \nstart I'm going to start with kind of a Java EE   application, it's kind of old school, we'll \ngo back you know maybe a decade. And let's say   that we've got some components in this Java EE app \nthat actually power it. So something important to   remember here although we might be using a SOA, or \nservice oriented architecture, this is not exactly   microservices. So they're not communicating over \nRest APIs. So you have some inherent advantages   here, for example you can take advantage of \nlike the framework the Java EE framework to   output log files which will probably all come \nout into the same directory and the timestamps   match up so things are good. In addition, you \ncould take advantage of something like an APM   solution which is kind of like a one size fits \nall set and forget so you install it and it'll   kind of get rich analytics and data and metrics \nabout the running services within the application.   So essentially what we've done is we've made \nour system observable so that you know our   Ops teams were then able to kind of look into \nit and identify problems and figure out you   know if anything needed to be done. So for the \nbusiness objectives back then this was essentially   good enough, but this tends to fall apart very \nquickly when you start to move to a more cloud   native approach where you have multiple run times \nand multiple kind of layers to the architecture. So let's say we have an example app here. So we'll \nsay we'll start with node as a front end. Let's   say we also have a Java backend application. And \nthen finally let's say we also have a Python app   which is doing some data processing. So let's \nsee how these things work with each other so   the front-end app probably talks to the Java app \nand also the Python app for some data processing.   The Java app probably communicates with a database \nand then the Python app probably talks to the Java   app for kind of crud operations. So this is kind \nof my quick sketch, kind of a dummy layout for a   microservices based application. You can take it a \nstep further and even say that this is all running   within Kubernetes. So we've got these \ncontainer-based applications running in a cluster.   So immediately the first problem I can \nsee here is that with multiple runtimes   we now have to think about multiple \ndifferent agents or ways to collect data.   So instead of just one APM tool we might have \nto start thinking about pulling in multiple   so how would we con consolidate all \nthat data right so that's a challenge.   In addition, let's think about things like \nlogging. So each of these runtimes probably   outputting logs in a different place, and you \nknow, we have to figure out how we consolidate   all those. Maybe we use a log streaming service. \nRegardless you can see the complexity starts to   grow. And finally, as you add more services and \nmicroservices components to this architecture,   say a user comes in where try to actually access \none of these services and they run into an error   you need to trace that request through the \nmultiple services. Well unless you have the   right architecture infrastructure in place, \nyou know something like headers on requests,   maybe a way to handle web sockets, things are \ngoing to start to get messy and you can see how   the technical complexity grows quite large. So \nhere's where Observability comes in and actually   differs, and differs itself from kind of standard \nAPM tools. It thinks about the more holistic cloud   cloud-native approach for being able to do \nthings like logging and monitoring and that   kind of thing. So I'll say there's three major \nsteps for any sort of Observability solution.   We'll start with the first one we'll call \nit collect, because we need to collect data.   Then we'll go to monitor, and we'll talk about \nthis because this is you know part of monitoring.   And finally we'll end with analyze, kind of doing \nsomething with the actual data that you have so   with the collect step, you know first thing let's \nsay that we actually made our system observable.   So the great thing is with Kubernetes you get \nsome CPU memory data automatically. So let's say   we get some of that, we get some logs from the \napplication all streaming to the same location   and let's say we even get some other stuff like \nhigh availability numbers or average latency,   you know things that we want to \nbe able to track and monitor.   So that brings me to my next step. \nSo once we have this data available   we need to be able to actually do something with \nit, at least visualizing it maybe if we're not   actually even solving problems yet what do \nwe do with this data. Well maybe we create   some dashboards to be able to monitor the \nhealth of our application, and say we create   multiple dashboards to be able to track different \nservices or kind of different business objectives,   high availability versus latency, that kind of \nthing. Now the final thing that I want to talk   about here is what do we do next. So say we found \nsome bug in the application by kind of looking   at our monitoring dashboards and we need to dive \nin deeper and fix the problem with the node app.   Well the great thing about that is an \nObservability solution should allow you to do   just that, it allows you to actually take it even \na step further because these days with Kubernetes   you're getting a lot of that information from the \nKubernetes layer. So this is something I want to   quickly pause and talk about. so with APM tools in \nthe past they were really kind of focused on kind   of like resource constraints, CPU usage, memory \nusage, that kind of thing. These days that's been   offloaded to the Kubernetes layer, so you know \nObservability kind of took APM and evolved it   to the next stage, pulled it a step up and \nenables our users to focus on things like   SLOs and SLIs, Service Level Objectives \nand Service Level Indicators.   So these will enable you to actually focus \non things that matter to your business.   So things like making sure that latencies \nare low or that application uptime is   high. So I think that's kind of the crucial three \nsteps for any sort of observability solution.   Let's take a step back again. These \nthings can be hard to set up on your own   with open source projects and capabilities \npulling all the different things together,   so you might be looking at an Enterprise \nObservability Solution and so when you're   comparing competitors and looking at building \nout your enterprise observability capability   I would look at kind of three main \nthings. Now let's start with automation.   Now every step of the way we need to make sure \nthat automation is there to make things easier   so let's say that our dev team pushes out a new \nversion of the node app and go from v1 to v2.   Now let's say they inadvertently introduced a \nbug. Instead of making a bulk API call they now   make individual API calls to the Python app. So \nin our monitoring dashboard our Ops team's like   oh guys something's wrong, the DB app is getting a \nlot of requests what's going on? Well you need to   be able to kind of automatically go back and trace \nthrough the requests and identify what happened.   That actually brings me to my second point as \nwell, which is context. It's always important,   I can spell, to have that context. So automation \nis important here because when upgrading to the   new version a node you want to make sure that the \nright agent is automatically installed and kind   of the instrumentation is in place so your \ndev team doesn't quite have to do that, and   as new services get added you want your monitoring \ndashboards to be automatically updated as well.   And that context is extremely crucial as with \nthis example we needed to be able to trace that   request back to the source of the problem. So once \nwe've traced that request back to the source with   that context that we have the third step here \nand I think probably one of the most important   is action. What do we actually do now? And that \nbrings me to my last step here the analyze phase,   which remember we talked about was \nkind of an evolution of traditional   APM tools to kind of the the way that \nObservability tools implement that today.   So when you get to this step you'll probably want \nto look at maybe the SLIs within the node app.   Maybe dive in deeper, right. So maybe you look \nin and you identify that you need to look at   application trace logs. So you look in the trace \nlogs and you identify some problems and you figure   out what the what the fix is you tell it to your \ndev team you know maybe the last step here is fix   and then rinse and repeat for any other \nissues that might come up in the future.   So I think Enterprise Observability is extremely \ncrucial here when we're kind of looking at   the bigger picture because it's not \njust about having the individual pieces,   which again like I said might be quite hard \nto set up with purely open source approaches,   but you want to think about automation to make \nsure things are kind of set up seamlessly to   reduce the overhead on your side. make sure you \nhave context to be able to see how services work   with each other maybe even generate things like \ndependency graphs to see the broader view because   you might not always have a light board like \nthis to see the architecture so cleanly. And   finally being able to take action when you do find \na problem. So making sure that your Observability   solution has a way to automatically pull together \ndata from multiple sources, multiple services,   and then figure out what's valid and necessary \nfor you to be able to make that fix happen. So   IBM is invested in making sure our clients can \neffectively set up Enterprise Observability   with the recent acquisition of Instanta. \nTo learn more about the acquisition,   or to get a showcase of the capabilities be sure \nto check out the links in the description below.   As always thanks for watching our videos. If you \nliked the video or have any questions or comments,   be sure to drop a like and a question or \ncomment below. Be sure to subscribe and   stay tuned for more videos like \nthis in the future. Thank you."
}