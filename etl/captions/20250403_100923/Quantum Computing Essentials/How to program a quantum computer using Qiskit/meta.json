{
  "video_url": "https://www.youtube.com/watch?v=Jx7IuJMYtJM",
  "video_id": "Jx7IuJMYtJM",
  "title": "How to program a quantum computer using Qiskit",
  "upload_date": "20220602",
  "channel": "IBM Technology",
  "duration": "5:59",
  "caption": "In my previous video, I talked about what quantum \ncomputing is and what makes it special. But as   a developer, I'm sure you want to know how to \nactually write a piece of code that would run   on a common computer. But before we dive into \nthat, let's just do a little bit of a quick   recap. Instead of the classical bits of 0s and 1s, \nquantum computers use qubits. A qubit can be a 0,   a 1, or any linear combination of the two. \nAnd that is what we called a superposition.   We can also entangle multiple qubits. So their\nstates become strongly correlated.  In order   to change the states of qubits, we apply \na series of gates, similar to the classical   logic gates. And in the end, we want to measure \nthese qubits so we can get the results.   So how do we take all these concepts into \ncode? And the answer is simple. We use a   quantum software development kit. In \nthis video, we will be using Qiskit.   Which is the most widely used quantum SDK today.   Qiskit is based on Python, which is fairly simple \nto learn, even if you've never used it before.   So let's write a simple program in his Qiskit. In this program, we will use two qubits.   We will put one into superposition, entangle it with the other, and then   do a measurement of both of them. And \nof course, all that is done using gates.   So let's start by importing quantum circuit from \nQiskit. We then can create a quantum circuit  with two quantum registers \nand two classical registers.   The quantum registers are used for quantum   computation. One for each qubit. And the classical \nregisters are used to store the measured results.   We need a classical registers because \neven though the physical world is quantum,   the majority of the classical \nworld is still classical.   And the classical registers allow us to bring \nquantum information back into the classical world.   So the next thing we want to do is \napply some gates. And in this program,   we're going to apply two gates. The \nfirst one is the Hadamard gate  on qubit 0. The Hadamard gate puts \nthe qubit into a superposition between 0   and 1. That means it now has an equal \nchance of being measured a 0 or 1.   The next gate we need is the control \nnot gate,  or \"cx\" for short.   The control not gate is a conditional two qubits gate. It has a control qubit and the target qubit. Without superposition, the control \nnot gate is fairly simple to understand.   That is, it is as if the state of the control qubit is \n1, then you flip the state of the target qubit.   And that's why it's called control not.   And because the states of least two \nqubits are now strongly correlated,   we now say they are entangled. So the \nlast thing we want to do is actually do   measurements so we can get the outputs. And we \ndo this by calling the measure all function.   And there you have it. We just wrote a simple \nquantum program using Qiskit. Now, if you take   this program and run it a bunch of times on an \nideal quantum computer, you'll find out that   there's a 50% chance of the outputs being 00 and \n50% chance of it being 11. But you would never   be a 01 or 10. The 50/50 of the first \nqubit comes from the superposition. And while   we didn't explicitly change the state of the \nsecond qubit, it got changed anyway because   it is entangled with the first qubit. \nSo it changes with the first qubit.   So in this program, we created a quantum \ncircuit which operates at the same level   as classical assembly language and allows you \nto efficiently manipulate the qubits directly.   However, if you're not fond of \nplaying with low level circuits,   Qiskit also offers a number of higher \nlevel algorithms. For example, Qiskit has   a package focusing on machine learning that has \na number of pre-built classes. You can take a   quantum kernel class, use it to train and test \ndata. You can then take this trained quantum   kernel and pass it into a classical algorithm \nsuch as the support vector classification   from scikit-learn. Then you can then \naccelerate your classical application.   Thanks for watching. If you have any questions, \nplease leave them in the comments below.   Also, please remember to Like this \nvideo and Subscribe to our channel   so we can continue to bring you \ncontent that matters to you."
}